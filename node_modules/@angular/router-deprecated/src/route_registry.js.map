{"version":3,"file":"route_registry.js","sourceRoot":"","sources":["../../../../modules/@angular/router-deprecated/src/route_registry.ts"],"names":[],"mappings":"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","sourcesContent":["import {ListWrapper, Map, StringMapWrapper} from '../src/facade/collection';\nimport {PromiseWrapper} from '../src/facade/async';\nimport {\n  isPresent,\n  isArray,\n  isBlank,\n  isType,\n  isString,\n  isStringMap,\n  Type,\n  StringWrapper,\n  Math,\n  getTypeNameForDebugging,\n} from '../src/facade/lang';\nimport {BaseException} from '../src/facade/exceptions';\nimport {Injectable, Inject, OpaqueToken, reflector} from '@angular/core';\nimport {RouteConfig, Route, AuxRoute, RouteDefinition} from './route_config/route_config_impl';\nimport {PathMatch, RedirectMatch, RouteMatch} from './rules/rules';\nimport {RuleSet} from './rules/rule_set';\nimport {\n  Instruction,\n  ResolvedInstruction,\n  RedirectInstruction,\n  UnresolvedInstruction,\n  DefaultInstruction\n} from './instruction';\nimport {normalizeRouteConfig, assertComponentExists} from './route_config/route_config_normalizer';\nimport {parser, Url, convertUrlParamsToArray} from './url_parser';\nimport {GeneratedUrl} from './rules/route_paths/route_path';\n\nvar _resolveToNull = PromiseWrapper.resolve<Instruction>(null);\n\n// A LinkItemArray is an array, which describes a set of routes\n// The items in the array are found in groups:\n// - the first item is the name of the route\n// - the next items are:\n//   - an object containing parameters\n//   - or an array describing an aux route\n// export type LinkRouteItem = string | Object;\n// export type LinkItem = LinkRouteItem | Array<LinkRouteItem>;\n// export type LinkItemArray = Array<LinkItem>;\n\n/**\n * Token used to bind the component with the top-level {@link RouteConfig}s for the\n * application.\n *\n * ### Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))\n *\n * ```\n * import {Component} from '@angular/core';\n * import {\n *   ROUTER_DIRECTIVES,\n *   ROUTER_PROVIDERS,\n *   RouteConfig\n * } from '@angular/router-deprecated';\n *\n * @Component({directives: [ROUTER_DIRECTIVES]})\n * @RouteConfig([\n *  {...},\n * ])\n * class AppCmp {\n *   // ...\n * }\n *\n * bootstrap(AppCmp, [ROUTER_PROVIDERS]);\n * ```\n */\nexport const ROUTER_PRIMARY_COMPONENT: OpaqueToken =\n    /*@ts2dart_const*/ new OpaqueToken('RouterPrimaryComponent');\n\n\n/**\n * The RouteRegistry holds route configurations for each component in an Angular app.\n * It is responsible for creating Instructions from URLs, and generating URLs based on route and\n * parameters.\n */\n@Injectable()\nexport class RouteRegistry {\n  private _rules = new Map<any, RuleSet>();\n\n  constructor(@Inject(ROUTER_PRIMARY_COMPONENT) private _rootComponent: Type) {}\n\n  /**\n   * Given a component and a configuration object, add the route to this registry\n   */\n  config(parentComponent: any, config: RouteDefinition): void {\n    config = normalizeRouteConfig(config, this);\n\n    // this is here because Dart type guard reasons\n    if (config instanceof Route) {\n      assertComponentExists(config.component, config.path);\n    } else if (config instanceof AuxRoute) {\n      assertComponentExists(config.component, config.path);\n    }\n\n    var rules = this._rules.get(parentComponent);\n\n    if (isBlank(rules)) {\n      rules = new RuleSet();\n      this._rules.set(parentComponent, rules);\n    }\n\n    var terminal = rules.config(config);\n\n    if (config instanceof Route) {\n      if (terminal) {\n        assertTerminalComponent(config.component, config.path);\n      } else {\n        this.configFromComponent(config.component);\n      }\n    }\n  }\n\n  /**\n   * Reads the annotations of a component and configures the registry based on them\n   */\n  configFromComponent(component: any): void {\n    if (!isType(component)) {\n      return;\n    }\n\n    // Don't read the annotations from a type more than once â€“\n    // this prevents an infinite loop if a component routes recursively.\n    if (this._rules.has(component)) {\n      return;\n    }\n    var annotations = reflector.annotations(component);\n    if (isPresent(annotations)) {\n      for (var i = 0; i < annotations.length; i++) {\n        var annotation = annotations[i];\n\n        if (annotation instanceof RouteConfig) {\n          let routeCfgs: RouteDefinition[] = annotation.configs;\n          routeCfgs.forEach(config => this.config(component, config));\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Given a URL and a parent component, return the most specific instruction for navigating\n   * the application into the state specified by the url\n   */\n  recognize(url: string, ancestorInstructions: Instruction[]): Promise<Instruction> {\n    var parsedUrl = parser.parse(url);\n    return this._recognize(parsedUrl, []);\n  }\n\n\n  /**\n   * Recognizes all parent-child routes, but creates unresolved auxiliary routes\n   */\n  private _recognize(parsedUrl: Url, ancestorInstructions: Instruction[],\n                     _aux = false): Promise<Instruction> {\n    var parentInstruction = ListWrapper.last(ancestorInstructions);\n    var parentComponent = isPresent(parentInstruction) ? parentInstruction.component.componentType :\n                                                         this._rootComponent;\n\n    var rules = this._rules.get(parentComponent);\n    if (isBlank(rules)) {\n      return _resolveToNull;\n    }\n\n    // Matches some beginning part of the given URL\n    var possibleMatches: Promise<RouteMatch>[] =\n        _aux ? rules.recognizeAuxiliary(parsedUrl) : rules.recognize(parsedUrl);\n\n    var matchPromises: Promise<Instruction>[] = possibleMatches.map(\n        (candidate: Promise<RouteMatch>) => candidate.then((candidate: RouteMatch) => {\n\n          if (candidate instanceof PathMatch) {\n            var auxParentInstructions: Instruction[] =\n                ancestorInstructions.length > 0 ? [ListWrapper.last(ancestorInstructions)] : [];\n            var auxInstructions =\n                this._auxRoutesToUnresolved(candidate.remainingAux, auxParentInstructions);\n\n            var instruction = new ResolvedInstruction(candidate.instruction, null, auxInstructions);\n\n            if (isBlank(candidate.instruction) || candidate.instruction.terminal) {\n              return instruction;\n            }\n\n            var newAncestorInstructions: Instruction[] = ancestorInstructions.concat([instruction]);\n\n            return this._recognize(candidate.remaining, newAncestorInstructions)\n                .then((childInstruction) => {\n                  if (isBlank(childInstruction)) {\n                    return null;\n                  }\n\n                  // redirect instructions are already absolute\n                  if (childInstruction instanceof RedirectInstruction) {\n                    return childInstruction;\n                  }\n                  instruction.child = childInstruction;\n                  return instruction;\n                });\n          }\n\n          if (candidate instanceof RedirectMatch) {\n            var instruction =\n                this.generate(candidate.redirectTo, ancestorInstructions.concat([null]));\n            return new RedirectInstruction(instruction.component, instruction.child,\n                                           instruction.auxInstruction, candidate.specificity);\n          }\n        }));\n\n    if ((isBlank(parsedUrl) || parsedUrl.path == '') && possibleMatches.length == 0) {\n      return PromiseWrapper.resolve(this.generateDefault(parentComponent));\n    }\n\n    return PromiseWrapper.all<Instruction>(matchPromises).then(mostSpecific);\n  }\n\n  private _auxRoutesToUnresolved(auxRoutes: Url[],\n                                 parentInstructions: Instruction[]): {[key: string]: Instruction} {\n    var unresolvedAuxInstructions: {[key: string]: Instruction} = {};\n\n    auxRoutes.forEach((auxUrl: Url) => {\n      unresolvedAuxInstructions[auxUrl.path] = new UnresolvedInstruction(\n          () => { return this._recognize(auxUrl, parentInstructions, true); });\n    });\n\n    return unresolvedAuxInstructions;\n  }\n\n\n  /**\n   * Given a normalized list with component names and params like: `['user', {id: 3 }]`\n   * generates a url with a leading slash relative to the provided `parentComponent`.\n   *\n   * If the optional param `_aux` is `true`, then we generate starting at an auxiliary\n   * route boundary.\n   */\n  generate(linkParams: any[], ancestorInstructions: Instruction[], _aux = false): Instruction {\n    var params = splitAndFlattenLinkParams(linkParams);\n    var prevInstruction;\n\n    // The first segment should be either '.' (generate from parent) or '' (generate from root).\n    // When we normalize above, we strip all the slashes, './' becomes '.' and '/' becomes ''.\n    if (ListWrapper.first(params) == '') {\n      params.shift();\n      prevInstruction = ListWrapper.first(ancestorInstructions);\n      ancestorInstructions = [];\n    } else {\n      prevInstruction = ancestorInstructions.length > 0 ? ancestorInstructions.pop() : null;\n\n      if (ListWrapper.first(params) == '.') {\n        params.shift();\n      } else if (ListWrapper.first(params) == '..') {\n        while (ListWrapper.first(params) == '..') {\n          if (ancestorInstructions.length <= 0) {\n            throw new BaseException(\n                `Link \"${ListWrapper.toJSON(linkParams)}\" has too many \"../\" segments.`);\n          }\n          prevInstruction = ancestorInstructions.pop();\n          params = ListWrapper.slice(params, 1);\n        }\n\n        // we're on to implicit child/sibling route\n      } else {\n        // we must only peak at the link param, and not consume it\n        let routeName = ListWrapper.first(params);\n        let parentComponentType = this._rootComponent;\n        let grandparentComponentType = null;\n\n        if (ancestorInstructions.length > 1) {\n          let parentComponentInstruction = ancestorInstructions[ancestorInstructions.length - 1];\n          let grandComponentInstruction = ancestorInstructions[ancestorInstructions.length - 2];\n\n          parentComponentType = parentComponentInstruction.component.componentType;\n          grandparentComponentType = grandComponentInstruction.component.componentType;\n        } else if (ancestorInstructions.length == 1) {\n          parentComponentType = ancestorInstructions[0].component.componentType;\n          grandparentComponentType = this._rootComponent;\n        }\n\n        // For a link with no leading `./`, `/`, or `../`, we look for a sibling and child.\n        // If both exist, we throw. Otherwise, we prefer whichever exists.\n        var childRouteExists = this.hasRoute(routeName, parentComponentType);\n        var parentRouteExists = isPresent(grandparentComponentType) &&\n                                this.hasRoute(routeName, grandparentComponentType);\n\n        if (parentRouteExists && childRouteExists) {\n          let msg =\n              `Link \"${ListWrapper.toJSON(linkParams)}\" is ambiguous, use \"./\" or \"../\" to disambiguate.`;\n          throw new BaseException(msg);\n        }\n\n        if (parentRouteExists) {\n          prevInstruction = ancestorInstructions.pop();\n        }\n      }\n    }\n\n    if (params[params.length - 1] == '') {\n      params.pop();\n    }\n\n    if (params.length > 0 && params[0] == '') {\n      params.shift();\n    }\n\n    if (params.length < 1) {\n      let msg = `Link \"${ListWrapper.toJSON(linkParams)}\" must include a route name.`;\n      throw new BaseException(msg);\n    }\n\n    var generatedInstruction =\n        this._generate(params, ancestorInstructions, prevInstruction, _aux, linkParams);\n\n    // we don't clone the first (root) element\n    for (var i = ancestorInstructions.length - 1; i >= 0; i--) {\n      let ancestorInstruction = ancestorInstructions[i];\n      if (isBlank(ancestorInstruction)) {\n        break;\n      }\n      generatedInstruction = ancestorInstruction.replaceChild(generatedInstruction);\n    }\n\n    return generatedInstruction;\n  }\n\n\n  /*\n   * Internal helper that does not make any assertions about the beginning of the link DSL.\n   * `ancestorInstructions` are parents that will be cloned.\n   * `prevInstruction` is the existing instruction that would be replaced, but which might have\n   * aux routes that need to be cloned.\n   */\n  private _generate(linkParams: any[], ancestorInstructions: Instruction[],\n                    prevInstruction: Instruction, _aux = false, _originalLink: any[]): Instruction {\n    let parentComponentType = this._rootComponent;\n    let componentInstruction = null;\n    let auxInstructions: {[key: string]: Instruction} = {};\n\n    let parentInstruction: Instruction = ListWrapper.last(ancestorInstructions);\n    if (isPresent(parentInstruction) && isPresent(parentInstruction.component)) {\n      parentComponentType = parentInstruction.component.componentType;\n    }\n\n    if (linkParams.length == 0) {\n      let defaultInstruction = this.generateDefault(parentComponentType);\n      if (isBlank(defaultInstruction)) {\n        throw new BaseException(\n            `Link \"${ListWrapper.toJSON(_originalLink)}\" does not resolve to a terminal instruction.`);\n      }\n      return defaultInstruction;\n    }\n\n    // for non-aux routes, we want to reuse the predecessor's existing primary and aux routes\n    // and only override routes for which the given link DSL provides\n    if (isPresent(prevInstruction) && !_aux) {\n      auxInstructions = StringMapWrapper.merge(prevInstruction.auxInstruction, auxInstructions);\n      componentInstruction = prevInstruction.component;\n    }\n\n    var rules = this._rules.get(parentComponentType);\n    if (isBlank(rules)) {\n      throw new BaseException(\n          `Component \"${getTypeNameForDebugging(parentComponentType)}\" has no route config.`);\n    }\n\n    let linkParamIndex = 0;\n    let routeParams: {[key: string]: any} = {};\n\n    // first, recognize the primary route if one is provided\n    if (linkParamIndex < linkParams.length && isString(linkParams[linkParamIndex])) {\n      let routeName = linkParams[linkParamIndex];\n      if (routeName == '' || routeName == '.' || routeName == '..') {\n        throw new BaseException(`\"${routeName}/\" is only allowed at the beginning of a link DSL.`);\n      }\n      linkParamIndex += 1;\n      if (linkParamIndex < linkParams.length) {\n        let linkParam = linkParams[linkParamIndex];\n        if (isStringMap(linkParam) && !isArray(linkParam)) {\n          routeParams = linkParam;\n          linkParamIndex += 1;\n        }\n      }\n      var routeRecognizer = (_aux ? rules.auxRulesByName : rules.rulesByName).get(routeName);\n\n      if (isBlank(routeRecognizer)) {\n        throw new BaseException(\n            `Component \"${getTypeNameForDebugging(parentComponentType)}\" has no route named \"${routeName}\".`);\n      }\n\n      // Create an \"unresolved instruction\" for async routes\n      // we'll figure out the rest of the route when we resolve the instruction and\n      // perform a navigation\n      if (isBlank(routeRecognizer.handler.componentType)) {\n        var generatedUrl: GeneratedUrl = routeRecognizer.generateComponentPathValues(routeParams);\n        return new UnresolvedInstruction(() => {\n          return routeRecognizer.handler.resolveComponentType().then((_) => {\n            return this._generate(linkParams, ancestorInstructions, prevInstruction, _aux,\n                                  _originalLink);\n          });\n        }, generatedUrl.urlPath, convertUrlParamsToArray(generatedUrl.urlParams));\n      }\n\n      componentInstruction = _aux ? rules.generateAuxiliary(routeName, routeParams) :\n                                    rules.generate(routeName, routeParams);\n    }\n\n    // Next, recognize auxiliary instructions.\n    // If we have an ancestor instruction, we preserve whatever aux routes are active from it.\n    while (linkParamIndex < linkParams.length && isArray(linkParams[linkParamIndex])) {\n      let auxParentInstruction: Instruction[] = [parentInstruction];\n      let auxInstruction = this._generate(linkParams[linkParamIndex], auxParentInstruction, null,\n                                          true, _originalLink);\n\n      // TODO: this will not work for aux routes with parameters or multiple segments\n      auxInstructions[auxInstruction.component.urlPath] = auxInstruction;\n      linkParamIndex += 1;\n    }\n\n    var instruction = new ResolvedInstruction(componentInstruction, null, auxInstructions);\n\n    // If the component is sync, we can generate resolved child route instructions\n    // If not, we'll resolve the instructions at navigation time\n    if (isPresent(componentInstruction) && isPresent(componentInstruction.componentType)) {\n      let childInstruction: Instruction = null;\n      if (componentInstruction.terminal) {\n        if (linkParamIndex >= linkParams.length) {\n          // TODO: throw that there are extra link params beyond the terminal component\n        }\n      } else {\n        let childAncestorComponents: Instruction[] = ancestorInstructions.concat([instruction]);\n        let remainingLinkParams = linkParams.slice(linkParamIndex);\n        childInstruction = this._generate(remainingLinkParams, childAncestorComponents, null, false,\n                                          _originalLink);\n      }\n      instruction.child = childInstruction;\n    }\n\n    return instruction;\n  }\n\n  public hasRoute(name: string, parentComponent: any): boolean {\n    var rules = this._rules.get(parentComponent);\n    if (isBlank(rules)) {\n      return false;\n    }\n    return rules.hasRoute(name);\n  }\n\n  public generateDefault(componentCursor: Type): Instruction {\n    if (isBlank(componentCursor)) {\n      return null;\n    }\n\n    var rules = this._rules.get(componentCursor);\n    if (isBlank(rules) || isBlank(rules.defaultRule)) {\n      return null;\n    }\n\n    var defaultChild = null;\n    if (isPresent(rules.defaultRule.handler.componentType)) {\n      var componentInstruction = rules.defaultRule.generate({});\n      if (!rules.defaultRule.terminal) {\n        defaultChild = this.generateDefault(rules.defaultRule.handler.componentType);\n      }\n      return new DefaultInstruction(componentInstruction, defaultChild);\n    }\n\n    return new UnresolvedInstruction(() => {\n      return rules.defaultRule.handler.resolveComponentType().then(\n          (_) => this.generateDefault(componentCursor));\n    });\n  }\n}\n\n/*\n * Given: ['/a/b', {c: 2}]\n * Returns: ['', 'a', 'b', {c: 2}]\n */\nfunction splitAndFlattenLinkParams(linkParams: any[]): any[] {\n  var accumulation = [];\n  linkParams.forEach(function(item: any) {\n    if (isString(item)) {\n      var strItem: string = <string>item;\n      accumulation = accumulation.concat(strItem.split('/'));\n    } else {\n      accumulation.push(item);\n    }\n  });\n  return accumulation;\n}\n\n\n/*\n * Given a list of instructions, returns the most specific instruction\n */\nfunction mostSpecific(instructions: Instruction[]): Instruction {\n  instructions = instructions.filter((instruction) => isPresent(instruction));\n  if (instructions.length == 0) {\n    return null;\n  }\n  if (instructions.length == 1) {\n    return instructions[0];\n  }\n  var first = instructions[0];\n  var rest = instructions.slice(1);\n  return rest.reduce((instruction: Instruction, contender: Instruction) => {\n    if (compareSpecificityStrings(contender.specificity, instruction.specificity) == -1) {\n      return contender;\n    }\n    return instruction;\n  }, first);\n}\n\n/*\n * Expects strings to be in the form of \"[0-2]+\"\n * Returns -1 if string A should be sorted above string B, 1 if it should be sorted after,\n * or 0 if they are the same.\n */\nfunction compareSpecificityStrings(a: string, b: string): number {\n  var l = Math.min(a.length, b.length);\n  for (var i = 0; i < l; i += 1) {\n    var ai = StringWrapper.charCodeAt(a, i);\n    var bi = StringWrapper.charCodeAt(b, i);\n    var difference = bi - ai;\n    if (difference != 0) {\n      return difference;\n    }\n  }\n  return a.length - b.length;\n}\n\nfunction assertTerminalComponent(component, path) {\n  if (!isType(component)) {\n    return;\n  }\n\n  var annotations = reflector.annotations(component);\n  if (isPresent(annotations)) {\n    for (var i = 0; i < annotations.length; i++) {\n      var annotation = annotations[i];\n\n      if (annotation instanceof RouteConfig) {\n        throw new BaseException(\n            `Child routes are not allowed for \"${path}\". Use \"...\" on the parent's route path.`);\n      }\n    }\n  }\n}\n"]}